package main

import "fmt"

/**
在大多数情况下，我们使用字面量就可以满足初始化值或变量的请求。除此之外，Go语言还为我们提供了两个用于数据初始化的内建函数new和make。

总结一下数据初始化的以下规则：
1、字面量可以用于初始化几乎所有的Go语言数据类型的值，除了接口类型和通道类型。接口类型没有值，而通道类型的值只能使用make函数来创建。如果需要指向值的
指针值 ，那么可以在表示该值的字面量上进行取址操作(&)。
2、内建函数new主要被用于创建值类型的值。调用new函数的表达式的结果值将会是指向被创建值的指针值，并且被创建值会是其所属数据类型的零值。因为，new函数
不适合用来创建引用类型的值。其直接的原因是引用类型的值的零值都是nil，是不可用的。
3、内建函数make仅能被用于切片类型、字典类型和通道类型的值的创建。它在创建值之后还会对其进行必要的初始化。与new函数不同，调用make函数的表达式的结果值
将会是被创建的值本身，而不是指向它的指针值。
*/
func main() {
	/**
	new用来分配内存的内建函数，但是与C++不一样的是，它并不初始化内存，只是将其置零。也就是说，new(T)会为T类型的新值分配并清零一块内存空间，
	并且返回它的地址，一个类型为*T的值，这个值总是指向T类型的零值。
	*/
	b := new(bool)
	fmt.Println(*b) // false
	i := new(int)
	fmt.Println(*i) // 0
	s := new(string)
	fmt.Println(*s) // ""
	var p *[]int = new([]int)
	fmt.Println(*p == nil) // true
	fmt.Println(p)         // &[]
	fmt.Println(*p)        // []
	var r []int = append(*p, 2)
	fmt.Println(r) // [2]

	/**
	make函数只能用于创建切片类型、字典类型和通道类型的值，并返回一个已被初始化的（非零值的）对应类型的值。在创建这3个引用类型的值的时候，必须将内存
	空间和数据初始化这两个步骤绑定在一起。make除了接受一个表示目标类型的类型字面量之外 ，还会接受一个或两个额外参数。
	*/
	// 创建一个新类型[]int的值，长度是10，容量是100。当然也可以省略掉最后一个参数，这样长度和容量一致。
	sl := make([]int, 10, 100)
	fmt.Println(sl) // [0 0 0 0 0 0 0 0 0 0]
	// 我们使用make函数创建字典类型的值的时候，也可以指定其底层数据结构的长度。但是，该字典值只会展示我们明确"放入"的键值对。虽然我们也可以忽略那个用于
	// 表示底层数据结构长度的参数，但还是建议：应该在性能敏感的场景下，合理设置该长度参数。
	m := make(map[string]int, 10)
	fmt.Println(m) // map[]
	m["age"] = 22
	m["name"] = 33
	fmt.Println(m) // map[age:22 name:33]
}
