package main

import "fmt"

/**
如果值x可以被赋给类型为T的变量，那么它们至少需要满足以下条件中的一个：
1、如果值x的类型就是T，那么x理所当然可以被赋给T类型的变量。
2、如果值x的类型是V，那么V和T应该具有相同的潜在类型，并且它们之中至少一个是未命名的类型。注意， 这里说的未命名的类型并不是指结构体类型中的匿名字段，
而是未被署名的数据类型。例如，下面的s所代表的值的类型是
struct {
		a int
		b string
	}
而这个类型就是一个未命名的类型。它的潜在类型与结构体类型Anonym相同。因此s可以被赋给类型Anonym的变量。
3、类型T是一个接口类型，且值x的类型实现了T。这种情况下，x就可以被赋给类型为T的变量。
4、如果x是一个双向通道类型的值，而T也是一个通道类型。那么x的类型V和T应该具有相同的元素类型，并且它们之间至少有一个是未命名类型。
5、如果值x是预定义标识符nil，那么它可以被赋给切片类型、字典类型、函数类型、接口类型、指针类型和通道类型的变量。也就是说，只要变量的值不是值类型的，
它就可以被赋予空值nil。
6、如果值x是一个由某个数据类型的值代表的无类型的常量，那么它就可以被赋给该数据类型的变量。
7、所有值都可以被赋给空标识符"_"，空标识符有时也称为占位标识符。
*/

type Anonym struct {
	a int
	b string
}

func main() {
	s := struct {
		a int
		b string
	}{1, "test"}
	fmt.Println(s.a)
	var anonym Anonym = s
	fmt.Println(anonym.b)
}
